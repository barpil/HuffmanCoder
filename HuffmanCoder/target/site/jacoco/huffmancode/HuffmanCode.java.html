<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="pl"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>HuffmanCode.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">AiSD2024ZEx5</a> &gt; <a href="index.source.html" class="el_package">huffmancode</a> &gt; <span class="el_source">HuffmanCode.java</span></div><h1>HuffmanCode.java</h1><pre class="source lang-java linenums">package huffmancode;

import huffmancode.readers.BitReader;
import huffmancode.structures.CharMap;
import huffmancode.structures.CharacterTree;
import huffmancode.structures.nodes.CharNode;
import huffmancode.writers.BinaryValuesWriter;

import java.io.*;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;


<span class="nc" id="L15">public class HuffmanCode {</span>
    private static BinaryValuesWriter bW;
    public static void encode(File entryFile){
        try {
<span class="nc" id="L19">            Path pathFile = Paths.get(&quot;results/result&quot;);</span>
<span class="nc bnc" id="L20" title="All 2 branches missed.">            if(!pathFile.getParent().toFile().exists()){</span>
<span class="nc" id="L21">                Files.createDirectories(pathFile.getParent());</span>
            }
            Path file;
<span class="nc bnc" id="L24" title="All 2 branches missed.">            if(!pathFile.toFile().exists()){</span>
<span class="nc" id="L25">                file = Files.createFile(pathFile);</span>
            }else{
<span class="nc" id="L27">                file = pathFile;</span>
            }
<span class="nc" id="L29">            encode(entryFile, file.toFile());</span>
<span class="nc" id="L30">        } catch (IOException e) {</span>
<span class="nc" id="L31">            System.err.println(&quot;\033[31mAn error occurred while trying to create result file!\033[0m&quot;);</span>
<span class="nc" id="L32">        }</span>
<span class="nc" id="L33">    }</span>

    public static void encode(File entryFile, File outFile){
<span class="fc" id="L36">        encodeFile(entryFile, outFile);</span>
<span class="fc" id="L37">        System.out.println(&quot;\n\033[32mEncoded &quot;+entryFile.length()+&quot;B into &quot;+outFile.length()+&quot;B\nResult saved at:\n&quot;+outFile.getAbsolutePath()+&quot;\033[0m&quot;);</span>
<span class="fc" id="L38">    }</span>

    private static StringBuilder byteCode;
    private static void encodeFile(File entryFile, File outFile) {
<span class="fc" id="L42">        CharMap charMap = EntryFileMaper.createCharMap(entryFile);</span>
<span class="fc" id="L43">        CharacterTree characterTree = new CharacterTree(charMap);</span>
<span class="fc" id="L44">        byteCode = new StringBuilder();</span>
<span class="fc" id="L45">        codeCharacters(entryFile, outFile, charMap, characterTree);</span>

<span class="fc" id="L47">    }</span>
    private static int numberOfBitsToFillToFullByte;
    private static void createTreeReconstructionCode(File entryFile, File outFile, CharMap charMap, CharacterTree characterTree) throws IOException {
        //Pierwsze 3 bity oznaczaja ilosc dodanych dodatkowych zer
        //dalej opisana jest rekonstrukcja drzewa
        //0 oznacza, że node jest CharNodem
        //1 oznacza, że node jest LeafCharNodem
        //Po dodaniu tego znowu nie bedzie mi sie zgadzac liczba bitow do dopelnienia bajtu
<span class="fc" id="L55">        StringBuilder characterCodes = new StringBuilder();</span>
<span class="fc" id="L56">        cTRC(characterCodes, characterTree.getRoot());</span>
<span class="fc" id="L57">        int tmp=(calculateNumberOfExtraBits(charMap,characterTree)+3+characterCodes.length())%8;</span>
<span class="pc bpc" id="L58" title="1 of 2 branches missed.">        numberOfBitsToFillToFullByte=(tmp==0)? 0:8-tmp; // Źle oblicza ilość brakujących bitów</span>

<span class="fc" id="L60">        bW.writeBinaryToFile(numberOfBitsToFillToFullByte,3);// Zapis 3 bitów mówiących o liczbie dopisanych na początek zakodowanego tesktu 0</span>
<span class="fc" id="L61">        bW.writeBinaryToFile(characterCodes.toString()); // Zapis drzewa kodow</span>

<span class="fc" id="L63">    }</span>
    //Plan jest taki, przy kodowaniu znaku rozbijam go na sume liczb mniejszych od 256 (takich co da sie zapisac na 8 bitach)
    //Na koncu kazdego takiego fragmentu zapisuje 0 albo 1. 0 oznacza ze to koniec sumy, 1 oznacza ze dalsze 8 bitow nalezy dodac do sumy.
    //Po natknieciu sie na 0 czyli osiagnieciu sumy znak bedzie zapisany w mapie znakow i nastepnie mozna dalej odkodowywac
    //budowe drzewa. W ten sposób jedynie znaki, które potrzebują tego będą zapisywane na wiecej niz 8 bitach.


    //2 Plan (lepszy)
    //Po wstawieniu 1 oznaczajacej ze jest to node ze znakiem zapisuje znak kontrolny 0 albo 1 oznaczajacy czy znak ma wartosc int &gt;255.
    //1 oznacza ze do wartosci int znaku wyjsciowego nalezy dodac 255. Jest tak aż do momentu napotkania 0.
    //Po 0 jest 8 bitow liczby mniejszej niz 255 oznaczajacej reszte z dzielenia wartosci int znaku przez 255.
    //Ergo przy odczycie powinny byc takie kroki:
    //Wykryto 1 - (node drzewa bedzie posiadal znak, wiec musimy go odczytac)
    //Iterujemy po jedynkach az natkniemy sie na 0. Po napotkaniu każdej jedynki dodajemy 255 do sumy.
    //Po natknieciu sie na 0 odczytujemy nastepne 8 bitow reszty, ktore przeksztalcone na dziesietny dodajemy do sumy
    //odkodowany znak zapisujemy w drzewie dekodujacym.

    private static void cTRC(StringBuilder sB, CharNode node){
<span class="pc bpc" id="L81" title="1 of 2 branches missed.">        if(node==null){</span>
<span class="nc" id="L82">            return;</span>
        }
<span class="pc bpc" id="L84" title="1 of 4 branches missed.">        if(node.getLeft()==null &amp;&amp; node.getRight()==null){</span>
<span class="fc" id="L85">            sB.append('1'); //Informacja o tym ze bedzie podawany kod znaku!</span>
<span class="fc bfc" id="L86" title="All 2 branches covered.">            for(int i=0;i&lt;((int)node.getCharacter()/255);i++){</span>
<span class="fc" id="L87">                sB.append('1'); //Dodanie dodatkowych jedynek oznaczajacych dodanie 255 do sumy znaku</span>
            }
<span class="fc" id="L89">            sB.append('0'); //Informacja o tym ze nastepne 8 bitow to reszta z sumy znaku</span>
<span class="fc" id="L90">            sB.append(BinaryValuesWriter.convertIntToBinaryString(node.getCharacter()%255,8)); //Zapisanie reszty znaku</span>
<span class="fc" id="L91">            return;</span>
        }
<span class="fc" id="L93">        sB.append('0');</span>
<span class="fc" id="L94">        cTRC(sB, node.getLeft());</span>
<span class="fc" id="L95">        cTRC(sB, node.getRight());</span>
<span class="fc" id="L96">    }</span>

    private static void codeCharacters(File entryFile, File outFile, CharMap charMap, CharacterTree characterTree){

<span class="fc" id="L100">        try(InputStreamReader iSR = new InputStreamReader(new FileInputStream(entryFile), &quot;UTF-8&quot;);</span>
<span class="fc" id="L101">            FileOutputStream fOS = new FileOutputStream(outFile)) {</span>
<span class="fc" id="L102">            bW = new BinaryValuesWriter(fOS);</span>
<span class="fc" id="L103">            createTreeReconstructionCode(entryFile, outFile, charMap, characterTree);</span>
<span class="fc bfc" id="L104" title="All 2 branches covered.">            for(int i=0;i&lt;numberOfBitsToFillToFullByte;i++){</span>
<span class="fc" id="L105">                bW.writeBinaryToFile(&quot;0&quot;);</span>
            }
            int c;
<span class="fc bfc" id="L108" title="All 2 branches covered.">            while((c= iSR.read())!=-1){</span>
<span class="fc" id="L109">                bW.writeBinaryToFile(characterTree.getCode((char) c));</span>
            }
<span class="nc" id="L111">        }catch (FileNotFoundException e) {</span>
<span class="nc" id="L112">        System.err.println(&quot;\033[31mError: Could not find specified entry file!\n(Passed path: &quot;+entryFile.getAbsolutePath()+&quot;\033[0m&quot;);</span>
<span class="nc" id="L113">        System.exit(1);</span>
<span class="nc" id="L114">    }catch (IOException e) {</span>
<span class="nc" id="L115">        System.err.println(&quot;\033[31mError: An IOException occured while trying to encode data!\n(Passed path: &quot;+entryFile.getAbsolutePath()+&quot;\033[0m&quot;);</span>
<span class="nc" id="L116">        System.exit(1);</span>
<span class="pc" id="L117">        }</span>
<span class="fc" id="L118">    }</span>




    private static int calculateNumberOfExtraBits(CharMap charMap, CharacterTree tree){
<span class="fc" id="L124">            int sum=0;</span>
<span class="fc" id="L125">            char[] array = charMap.getArrayOfSavedCharacters();</span>
<span class="fc bfc" id="L126" title="All 2 branches covered.">            for(char c: array){</span>
<span class="fc" id="L127">                int n= charMap.get(c).getCounter();</span>
<span class="fc" id="L128">                int x= tree.getCode(c).length();</span>
<span class="fc" id="L129">                sum+=n*x;</span>
<span class="fc" id="L130">                sum=sum%8;</span>
            }
<span class="fc" id="L132">            return sum;</span>
    }

    public static void decode(File entryFile){
        try {
<span class="nc" id="L137">            Path pathFile = Paths.get(&quot;results/result&quot;);</span>
<span class="nc bnc" id="L138" title="All 2 branches missed.">            if(!pathFile.getParent().toFile().exists()){</span>
<span class="nc" id="L139">                Files.createDirectories(pathFile.getParent());</span>
            }
            Path file;
<span class="nc bnc" id="L142" title="All 2 branches missed.">            if(!pathFile.toFile().exists()){</span>
<span class="nc" id="L143">                file = Files.createFile(pathFile);</span>
            }else{
<span class="nc" id="L145">                file = pathFile;</span>
            }
<span class="nc" id="L147">            decode(entryFile, file.toFile());</span>
<span class="nc" id="L148">        } catch (IOException e) {</span>
<span class="nc" id="L149">            System.err.println(&quot;\033[31mAn error occurred while trying to create result file!\033[0m&quot;);</span>
<span class="nc" id="L150">        }</span>
<span class="nc" id="L151">    }</span>

    public static void decode(File entryFile, File outputFile){
<span class="fc" id="L154">        decodeFile(entryFile, outputFile);</span>
<span class="fc" id="L155">        System.out.println(&quot;\n\033[32mDecoded &quot;+entryFile.length()+&quot;B into &quot;+outputFile.length()+&quot;B\nResult saved at:\n&quot;+outputFile.getAbsolutePath()+&quot;\033[0m&quot;);</span>
<span class="fc" id="L156">    }</span>

    private static void decodeFile(File entryFile, File outputFile){
<span class="fc" id="L159">        try(FileInputStream fIS = new FileInputStream(entryFile); OutputStreamWriter oSW = new OutputStreamWriter(new FileOutputStream(outputFile),&quot;UTF-8&quot;)){</span>
<span class="fc" id="L160">            BitReader bitReader = new BitReader(fIS);</span>
<span class="fc" id="L161">            StringBuilder stringBuilder = new StringBuilder();</span>
<span class="fc" id="L162">            int numberOfExtra0 = Integer.parseInt(bitReader.readBits(3),2);</span>
<span class="fc" id="L163">            CharacterTree characterTree = new CharacterTree(bitReader);</span>
<span class="fc" id="L164">            bitReader.readBits(numberOfExtra0);</span>
            int c;
            int character;
<span class="fc bfc" id="L167" title="All 2 branches covered.">            while((c=bitReader.readBit())!=-1){</span>
<span class="fc" id="L168">                stringBuilder.append((char)c);</span>
<span class="fc bfc" id="L169" title="All 2 branches covered.">                if((character=characterTree.getCharacter(stringBuilder.toString()))!='\u0000'){</span>
<span class="fc" id="L170">                    oSW.write(character);</span>
<span class="fc" id="L171">                    stringBuilder.setLength(0);</span>
                }
            }

<span class="nc" id="L175">        } catch (FileNotFoundException e) {</span>
<span class="nc" id="L176">            System.err.println(&quot;\033[31mError: Could not find specified entry file!\n(Passed path: &quot;+entryFile.getAbsolutePath()+&quot;\033[0m&quot;);</span>
<span class="nc" id="L177">            System.exit(1);</span>
<span class="nc" id="L178">        } catch (IOException e) {</span>
<span class="nc" id="L179">            System.err.println(&quot;\033[31mError: An IOException occured while trying to decode data!\n(Passed path: &quot;+entryFile.getAbsolutePath()+&quot;\033[0m&quot;);</span>
<span class="nc" id="L180">            System.exit(1);</span>
<span class="pc" id="L181">        }</span>
<span class="fc" id="L182">    }</span>



}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.12.202403310830</span></div></body></html>